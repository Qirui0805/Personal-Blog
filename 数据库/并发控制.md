## 并发控制

### 并发控制机制
参考：
		[面试必备之乐观锁与悲观锁](http://www.imooc.com/article/details/id/44217)
		[浅入浅出mysql](https://draveness.me/mysql-innodb)
#### 乐观锁，悲观锁
		
- 乐观锁，它会先尝试对资源进行修改，在写回时判断资源是否有其他线程对其进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁
		
- 悲观锁：在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；如以下会提到的表锁，行锁，读写锁等。Java中的syncronized和ReentrantLock也是该思想的实现

		
乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时（多写场景）更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候（多读场景，冲突较少）使用乐观锁就能较好的解决问题，在这时使用悲观锁就可能出现严重的性能问题；在选择并发控制机制时，需要综合考虑上面的四个方面（冲突频率、重试成本、响应速度和并发量）进行选择。
	
#### 锁粒度
	
MySQL 中提供了两种封锁粒度：**行级锁（row lock）表级锁（table lock）**。
应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。
但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。
在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。
		
#### 锁类型
##### 读写锁
为了最大化事务的并发能力
- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：  
• 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。   
• 一个事务对数据对象 A 加了 S 锁，  
• 可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。  

锁的兼容关系如下：  
						-	X	S  
						X	×	×  
						S	×	√     
##### 意向锁(Intention Lock)
参考：[详解 MySql InnoDB 中意向锁的作用](https://juejin.im/post/5b85124f5188253010326360)  

意向锁是一种不与行级锁冲突表级锁。  

• 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）  
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。  
``SELECT column FROM table ... LOCK IN SHARE MODE;``  

• 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）  
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。  
``SELECT column FROM table ... FOR UPDATE;``  
即：意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。  
		
在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。  
通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。  

各种锁的兼容关系如下：
					-	X	IX	S	IS  
					X	×	×	×	×  
					IX	×	√	×	√  
					S	×	×	√	√  
					IS	×	√	√	√  
解释如下：  
• 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；  
• S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。  
• 表锁不与行锁冲突  
  
举例说明意向锁作用：
事务 A 先获取了某一行的排他锁，并未提交：  
	``SELECT * FROM users WHERE id = 6 FOR UPDATE;``  
	a. 事务 A 获取了 users 表上的意向排他锁。  
	b. 事务 A 获取了 id 为 6 的数据行上的排他锁。  
之后事务 B 想要获取 users 表的共享锁：  
	``LOCK TABLES users READ;``  
	a. 事务 B 检测到事务 A 持有 users 表的意向排他锁。  
	b. 事务 B 对 users 表的加锁请求被阻塞（排斥）。  
最后事务 C 也想获取 users 表中某一行的排他锁：  
	``SELECT * FROM users WHERE id = 5 FOR UPDATE;``  
	a. 事务 C 申请 users 表的意向排他锁。  
	b. 事务 C 检测到事务 A 持有 users 表的意向排他锁。  
	c. 因为意向锁之间并不互斥，所以事务 C 获取到了 users 表的意向排他锁。  
	d. 因为id 为 5 的数据行上不存在任何排他锁，最终事务 C 成功获取到了该数据行上的排他锁。  

总结：意向锁的作用是提升判断锁时的效率，在加行级锁前需要加意向锁；意向锁之间互相兼容，只阻塞表级锁。
	
#### 锁的算法
[MVCC+锁的算法及实例分析](http://zhongmingmao.me/2017/05/18/innodb-next-key-lock/)
	
锁的本质：锁住某索引或索引间隙，而非数据。
##### 记录锁（record lock）
记录锁就是为某行记录加锁，它封锁该行的索引记录。如果是辅助索引，其对应的聚集索引记录也会被封锁。
		-- id 列为主键列或唯一索引列
``SELECT * FROM table WHERE id = 1 FOR UPDATE;``
		（该命令将使线程获得id=1索引的X锁）
		需要注意的是：id 列必须为唯一索引列（unique key )或主键列，否则上述语句加的锁就会变成临键锁。
		同时查询语句必须为精准匹配（=），不能为 >、<、like等，否则也会退化成临键锁
##### 间隙锁（gap lock）
使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。
			``SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;``
		除了手动加锁外，在执行完某些 SQL 后，InnoDB 也会自动加间隙锁，这个我们在下面会提到。
		
a. Gap S-Lock与Gap X-Lock是兼容的
b. Gap Lock只能_阻止其他事务在该Gap中插入记录_，但无法阻止其他事务获取同一个Gap上的Gap Lock（实例）
获取之后两个线程均不能插入数据；
c. 禁用Gap Lock的两种方式
○ 将事务隔离级别设置为READ COMMITTED

○ 将变量innodb_locks_unsafe_for_binlog（已弃用）设置为
		
##### 临键锁（next-key lock）
A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record. 
		基于非唯一索引或区间查询或查询不能精准匹配，若是唯一索引且能精准匹配则退化为记录锁。
		a. Next-Key Lock = Record Lock + Gap Lock
		b. 若索引a为10、11、13、20，可锁定的区间为(-∞, 10]、(10, 11]、(11, 13]、(13, 20]、(20, +∞)
			○ 若执行Select...Where a=13 For Update，将在a=13上有1个X Lock和在(11, 13)有1个Gap Lock
			○ a=13的下一个键为a=20，将在a=20有1个X Lock，在(13, 20)有1个Gap Lock
			○ 因此，在a=13上有1个X Lock，在(11, 20]上的有1个Gap Lock
			○ 也可以分解为在a=13和a=20上有2个X Lock，在(11,13)和(13,20)上有2个Gap Lock
		c. 在InnoDB默认事务隔离级别REPEATABLE READ(RR)下，支持Next-Key Lock
	
经实验，上面的例子中并不能获得20的x锁，即开区间，但是如果是范围查找，则可以获得后一段的x锁，即左开右闭
	
##### MySQL 隐式与显示锁定
	
MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。
InnoDB 也可以使用特定的语句进行显示锁定：
				``SELECT ... LOCK In SHARE MODE;``
                ``SELECT ... FOR UPDATE;``
	
#### 死锁的发生
##### mysql死锁情况

两个会话都持有一个锁，并且尝试获取对方的锁时就会发生死锁，不过 MySQL 也能在发生死锁时及时发现问题，并保证其中的一个事务能够正常工作，这对我们来说也是一个好消息。

#### 并发一致性问题
	
参考：解决死锁之路 - 学习事务与隔离级别
	
##### 事务与隔离级别
	
• RAED UNCOMMITED：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；
• READ COMMITED：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；
• REPEATABLE READ：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；
• SERIALIZABLE：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；
MySQL 中默认的事务隔离级别就是 REPEATABLE READ，但是它通过 Next-Key 锁也能够在某种程度上解决幻读的问题。

		
- 丢失修改
		T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。
	
- 脏读（dirty read)
		T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。or 事务可以读未提交的数据

	
- 不可重复读(non repeatable read)
		T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

							
- 幻影读（phantom read)
		幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。

							
	产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。
	
#### 封锁协议

##### 三级封锁协议
	
传统的隔离级别控制即是通过锁实现的，这种方式叫做 基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC），但没有办法解决读写的冲突，InnoDB引入了MVCC解决这个问题
	
- 一级封锁协议
	事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。
	可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

- 二级封锁协议
	在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。
	可以解决脏读问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。
				
- 三级封锁协议
	在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。
	可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。
							
##### 两段锁协议(2PL)
加锁和解锁分为两个阶段进行。
		可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。
		事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。
		lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
		但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。
		lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
	
并发调度：安排事务执行的次序称为调度，利用分时的方法同时处理多个事务称为并发调度。
	可串行化调度：当且仅当事务的并发调度结果与以某一次序串行调度的结果相同时，认为事务并发调度的结果是正确的，成为可串行化调度
	
#### 多版本并发控制
参考：[MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)

MVCC(Multiversion concurrency control) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制
	
是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别，实现的区别在于read view的创建。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

隐藏的列  
每一行额外包含三个隐藏字段：  
○ 6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。  
○ 7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。  
如果一行记录被更新, 则 undo log record 包含 '重建该行记录被更新之前内容' 所必须的信息。  
○ 6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中  
		
InnoDB表的组织方式为聚簇索引，索引记录包含了DB_TRX_ID，DB_ROLL_PTR两个字段，无论是聚簇索引还是二级索引（辅助索引）都有DELETED BIT，0表示未删除，1反之。  
##### Undo 日志
参考：[InnoDB多版本(MVCC)实现简要分析 --何登成](https://blog.csdn.net/shaochenshuo/article/details/76137652)、 [详细分析MySQL事务日志undo log](https://juejin.im/post/5c68a5e551882562eb50ee41)
		MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。
		undo logs分为: insert undo log 和 update undo log
		• insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。
		• update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。
		

各个操作后undo是如何记录的参照参考博客中的第一个
##### Read view(or snapshot or 快照）
• 用来做可见性判断的
• 在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;
• 在innodb中(默认read committed级别), 事务中每条select语句都会创建一个快照(read view);
	
read view参数分析参考[这篇博客](https://github.com/zhangyachen/zhangyachen.github.io/issues/68)
		read view 创建时间分析[MySQL 一致性读 深入研究](https://www.cnblogs.com/digdeep/p/4947694.html)
	
##### 实现过程（InnoDB在实现时有所不同）
	
以下实现过程针对可重复读隔离级别。
当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。
1. SELECT
	多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。
	把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于等于 T 的版本号，因为如果大于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须是未定义或者大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。
2. INSERT
	将当前系统版本号作为数据行快照的创建版本号。
3. DELETE
	将当前系统版本号作为数据行快照的删除版本号。
4. UPDATE
	将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。

#### InnoDB可见性算法
		
设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 trx_id_current，当前新开事务id为 new_id，当前新开事务创建的快照read view 中最早的事务id为up_limit_id, 最迟的事务id为low_limit_id(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)   
比较:
- 1.trx_id_current < up_limit_id, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.
- 2.trx_id_current >= trx_id_last, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。
- 3.trx_id_current <= trx_id_current <= trx_id_last, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。
- 4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 trx_id_current，然后跳到步骤1重新开始判断。
- 5.将该可见行的值返回
		
##### 快照读与当前读
1. 快照读（snapshot read) or 非阻塞读（Nonlocking Read）RR 隔离级别下的叫做 一致性非阻塞读（Consistent Nonlocking Read）
	使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。
		select * from table ...;
2. 当前读(current read)
		读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。
```
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update;
delete;
```
在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。
	innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读
	




